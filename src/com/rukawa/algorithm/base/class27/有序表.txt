搜索二叉树
搜索二叉树一定要说明以什么标准来排序
经典的搜索二叉树，树上没有重复的用来排序的key值
如果有重复节点的需求，可以在一个节点内部增加数据项

搜索二叉树查询key(查询某个key存在还是不存在)
1、如果当前节点的value==key，返回true
2、如果当前节点的value<key，当前节点向左移动
3、如果当前节点的value>key，当前节点向右移动
4、如果当前节点变成null，返回false

搜索二叉树插入新的key
和查询过程一样，但当前节点滑到空的时候，就插入在这里

搜索二叉树删除key
1、先找到key所在的节点
2、如果该节点没有左孩子，没有右孩子，直接删除即可
3、如果该节点有左孩子，没有右孩子，直接用左孩子顶替该节点
4、如果该节点没有左孩子，有右孩子，直接用右孩子顶替该节点
5、如果该节点有左孩子，有右孩子，用该节点后继节点顶替该节点

搜索二叉树特别不讲究
1、基础的搜索二叉树，添加、删除时候不照顾平衡性
2、数据状况很差的时候，性能很差
给搜索二叉树引入两个动作：左旋、右旋

AVL树、SB树、红黑树的共性
1、都是搜索二叉树
2、插入、删除、查询(一切查询)搜索二叉树该怎么做，这些结构都这么做
3、使用调整的基本动作都只有左旋和右旋
4、插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查
5、因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)

AVL树、SB树、红黑树的不同
1、平衡性的约束不同：AVL树最严格，SB树稍宽松，红黑树最宽松
2、插入、删除和搜索二叉树一样，但是额外，做各自的平衡性调整。各自的平衡性调整所使用的动作都是左旋或者右旋

AVL树
1、最严格的平衡性，任何节点左树高度和右树高度差不超过1
2、往上沿途检查每个节点时，都会检查四种违规的情况：LL、RR、LR、RL
3、不同情况虽然看起来复杂，但是核心是：LL(做一次右旋)、RR(做一次左旋)、LR和RL(利用旋转让底层那个上到顶部)

SB树
1、让每一个叔叔节点为头的树，节点个数都不少于其任何一个侄子节点
2、也是从底层被影响节点开始向上做路径每个节点检查
3、与AVL树非常像，也是四种违规类型：LL、RR、LR、RL
4、与AVL树非常像，核心点：LL(做一次右旋)、RR(做一次左旋)、LR和RL(利用旋转让底层那个上到顶部)
5、与AVL树不同的是，每轮经过调整后，谁的孩子发生变化了，谁就再查

SB树在使用时的改进
1、删除时候可以不用检查
2、就把平衡性的调整放在插入的时候
3、因为这种只要变就递归的特性，别的树没有
4、可以在节点上封装别的数据项，来增加功能

跳表(SkipList)
1、结构上根本和搜索二叉树无关
2、利用随机概率分布来使得高层索引可以无视数据规律，做到整体性能优良
3、思想是所有有序表中最先进的
4、结构简单就是多级单链表

聊聊红黑树
1、平衡性规定非常诡异
2、平衡性调整最为复杂
3、优点在于每次插入删除扰动较好，但是在今天看来这个优势也及其微弱了。原因：贪图扰动小的话，B+树、2-3-4树可能更好，还是那句话，到底图什么
4、除此之外，红黑树也不比AVL树、SB树、跳表更加优秀
5、面试上遇到过，说清楚原理，不行就举报

