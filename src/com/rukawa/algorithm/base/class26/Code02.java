package com.rukawa.algorithm.base.class26;

/**
 * create by hqh on 2023/1/8
 */
public class Code02 {
    /**
     * 32位无符号整数的范围是0～4294967295(0~2^32-1)
     * 现有一个正好包含40亿个无符号整数的文件，
     * 所以在整个范围中必然存在没有出现过的数
     * 可以使用最多1GB的内存，怎么找到所有未出现过的数？
     *
     * 进阶：内存限制为3KB，但是只要找到一个没出现过的数即可
     */
    /**
     * 1、位图实现
     *  a、有一个bit类型的数组，数组的每一个位置占用一个bit，8bit才占用1Byte，数组范围是0～2^32-1，下标总共有0～2^32-1个bit，
     *  实际占用2^32-1/8个Byte，肯定是小于1GB的内存
     *  b、怎么实现bit数组，用基础类型拼，比如：用一个长度为10的int数组，数组每一个位置占用32位，总共有320个bit
     *  c、i号位置bit设置：先用i/32确定在数组中的哪个位置，然后i%32确定这个位置中第几位
     *  d、把所有数字挨个确定位置和bit，设置状态为1
     *  e、最后位图中状态为0的就是没有出现过的数
     *
     * 2、内存3KB，找到一个没有出现过的数即可
     *  a、3KB的空间，用来存储int数组，数组最大能有多长，3000/4=750  所以int数组长度最大750
     *  b、选择离750最近的2的某次方，得到512，数组长度选择512，肯定不会爆掉
     *  c、int数组的长度最大是2^32，确定的 512 能被 2^32 整除，512份中每一个存储的8388608的范围
     *  d、无符号整数有43亿的范围，但是文件只有40亿个无符号整数，某一个范围不够8388608，所以找这个不满的范围中找到没有出现的数字
     *  e、对这个小范围继续进行512拆分，继续可以得到不满的范围，继续拆分为512份，依次拆分查找不满的范围，就能定位出没有出现过的数
     *
     * 2、有限几个变量，找到一个没有出现过的数即可
     *  a、确定L位置是0，R位置是2^32-1，确定mid
     *  b、左右两边，各有2^31个范围，哪一个范围不足2^31,在不满的区间继续二分
     *  c、依次二分查找，就能得到没有出现过的数
     */

    public static void main(String[] args) {
        int[] arr = new int[10];
        // arr[0]  int 32位
        // ...
        // arr[9]  int 32位

        int i = 179;
        int position = i / 32;
        int bit = i % 32;
        int status = (arr[position] & (1 << (bit))) == 0 ? 0 : 1;
    }
}
