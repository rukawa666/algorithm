package com.rukawa.algorithm.base.class28;

/**
 * create by hqh on 2023/1/9
 */
public class Code05_SubSequenceMaxModM {
    /**
     * 给定一个非负数组arr，和一个正数m。返回arr的所有子序列中累加和%m之后的最大值
     */
    /**
     * 根据数据量猜解法：
     *  1、假设arr中的数字的值都不大(100以内)，长度也不大(1000~2000)，但是m很大(10^12)，可以使用最经典的背包解法
     *  dp含义：自由使用0~i的这些数字，能不能把某一个累加和j搞出来
     *  情况1：不要i的数字，去判断0~i-1之间的数字随便选择，能不能搞出来累加和j，如果它能，自己也能
     *  情况2：要i的数字，去判断0~i-1之间的数字随便选择，把i位置的数字去掉，看不能搞出j-arr[i]的累加和，如果能，自己也能
     *
     *  2、如果arr中的数字很大，但是m不大，上面的情况会失效，列可能会超出10^8。
     *  dp[i][j]含义：arr中自由选择0~i的数字，搞出的所有累加和%m之后有没有余数j
     *  假设 dp[7][5] m=8, 自由使用arr[0...7]的所有数字，搞出的累加和%8之后有没有余数5
     *  情况1：不要i的数字，判断0~6之间的所有数字，累加和%m等于5，如果它能，自己也能
     *  情况2：要i的数字，假设arr[7]=3, 3%8=3，所以在0~6的范围上能凑出余数2，自己能凑出余数5
     *                 假设arr[7]=30,30%8=6，所以在0~6的范围上能凑出余数7(8+5-6)，自己能凑出余数5
     *                 假设arr[7]=12,12%8=4, 所以在0~6的范围上能凑出余数1(能不能凑出余数17 17%8=1)，因为j<m
     *
     *  3、如果arr中的数字很大，但是m也很大，但是arr的长度在30以内，此时可以用分治算法
     *  用分治，可得到2^30，大概10^9，此时超出10^8，可以拆分成两块，各为2^15(单独搞定一边的有多少余数)
     *
     */
}
