package com.rukawa.algorithm.types.dp.quadrilateral;

/**
 * @className: Code06_ThrowChessPiecesProblem
 * @description: TODO 类描述
 * @author: 鎏川疯
 * @date: 2021/7/20 0020 22:28
 **/
public class Code06_ThrowChessPiecesProblem {
    /**
     * 一座大楼有0~N层，地面算作第0层，最高的一层为第N层。已知棋子从第0层掉落肯定不会摔碎，从第i层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)。
     * 给定整数N作为楼层数，再给定整数K作为棋子数，返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数。一次只能扔一个棋子。
     * 【举例】
     * N=10，K=1。
     * 返回10。因为只有1棵棋子，所以不得不从第1层开始一直试到第10 层，在最差的情况下，即第10层 是不会摔坏的最高层，最少也要扔10次。
     * N=3，K=2。
     * 返回 2。
     * 先在2层扔1棵棋子如果碎了，试第1层，如果没碎，试第3层。 N=105，K=2 返回14。
     * 第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13。 若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26。
     * 若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试 28~38。 若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49。
     * 若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试 51~59。 若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试 61~68。
     * 若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试 70~76。 若没碎，第一个棋子继续在84层 扔，碎了则用仅存的一个棋子试 78~83。
     * 若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试 85~89。 若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试 91~94。
     * 若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试 96~98。 若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101。
     * 若没碎，第一个棋子继续在104 层扔，碎了则用仅存的一个棋子试103。 若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果。
     */
    public static int superEggDrop1(int kChess, int nLevel) {
        return 0;
    }

}
